#!/usr/bin/python2.7

# Copyright (c) 2017 King's College London
# created by the Software Development Team <http://soft-dev.org/>
#
# The Universal Permissive License (UPL), Version 1.0
#
# Subject to the condition set forth below, permission is hereby granted to any
# person obtaining a copy of this software, associated documentation and/or
# data (collectively the "Software"), free of charge and under any and all
# copyright rights in the Software, and any and all patent rights owned or
# freely licensable by each licensor hereunder covering either (i) the
# unmodified Software as contributed to or provided by such licensor, or (ii)
# the Larger Works (as defined below), to deal in both
#
# (a) the Software, and
# (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
# one is included with the Software (each a "Larger Work" to which the Software
# is contributed by such licensors),
#
# without restriction, including without limitation the rights to copy, create
# derivative works of, display, perform, and distribute the Software and make,
# use, sell, offer for sale, import, export, have made, and have sold the
# Software and the Larger Work(s), and to sublicense the foregoing rights on
# either these or other terms.
#
# This license is subject to the following condition: The above copyright
# notice and either this complete permission notice or at a minimum a reference
# to the UPL must be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import copy
import glob
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as pyplot
from matplotlib.backends.backend_pdf import PdfPages
import os
import os.path
import sys


sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from warmup.krun_results import parse_krun_file_with_changepoints
from warmup.latex import end_document, preamble
from warmup.plotting import add_margin_to_axes, compute_grid_offsets, style_axis, STYLE_DICT

# Set matplotlib styles, similar to Seaborn 'whitegrid'.
for style in STYLE_DICT:
    matplotlib.rcParams[style] = STYLE_DICT[style]

# Default (PDF) font sizes
TICK_FONTSIZE = 8
AXIS_FONTSIZE = 8

GRID_MAJOR_X_DIVS = 10
GRID_MAJOR_Y_DIVS = 10

LINE_COLOUR = 'k'
LINE_WIDTH = 1

DEFAULT_ITERS = 2000  # Iterations in original data file.
ITER_STEP = 10  # Truncated data files each differ by ITER_STEP iterations.

pyplot.figure(tight_layout=True)


def summarise_truncated(data_dir):
    """Summarise classifications in truncated data that match the original."""

    truncated_results = dict()
    original_results = None
    for filename in glob.glob(os.path.join(data_dir, '*_changepoints.json.bz2')):
        if 'truncated_' not in filename:  # Original results file.
            print 'Loading original results.'
            _, original_results = parse_krun_file_with_changepoints([filename])
            truncated_results[2000] = copy.deepcopy(original_results)
        else:
            last_iter = filename.split('.')[0].split('_')[1]
            print 'Loading last iter', last_iter, 'results file.'
            _, truncated_results[int(last_iter)] = parse_krun_file_with_changepoints([filename])
    assert original_results is not None, 'No original results file.'
    assert len(original_results.keys()) == 1, 'Expected one machine per results file.'
    machine = original_results.keys()[0]
    summary = dict()
    for last_iter in truncated_results:
        if last_iter not in summary:
            summary[last_iter] = { 'same': 0, 'different': 0 }
        for key in truncated_results[last_iter][machine]['classifications']:
            for p_exec in xrange(len(truncated_results[last_iter][machine]['classifications'][key])):
                if original_results[machine]['classifications'][key][p_exec] == \
                      truncated_results[last_iter][machine]['classifications'][key][p_exec]:
                    summary[last_iter]['same'] += 1
                else:
                    summary[last_iter]['different'] += 1
    return summary


def start_table(format_, headings):
    return """
{
\\begin{longtable}{%s}
\\toprule
%s \\\\
\\midrule
""" % (format_, headings)


def end_table():
    return """
\\bottomrule
\\end{longtable}
}
"""


def write_table(summary, outfile, with_preamble=False):
    """Write out a LaTeX table, with or without preamble."""

    table_format = 'l' + ('r' * 6)
    table_headings = '&'.join(['\\textbf{\\# Iterations}', '\\textbf{\\# Same}',
                              '\\textbf{\\# Different}', '\\textbf{\\# Delta}',
                              '\\textbf{\\% Same}', '\\textbf{\\% Different}',
                              '\\textbf{\\% Delta}',])
    total_original = float(summary[DEFAULT_ITERS]['same'] + summary[DEFAULT_ITERS]['different'])
    with open(outfile, 'w') as fp:
        if with_preamble:
            fp.write(preamble('Truncated data results'))
            fp.write('\\centering\n')
        fp.write(start_table(table_format, table_headings))
        for last_iter in sorted(summary, reverse=True):
            total = float(summary[last_iter]['same'] + summary[last_iter]['different'])
            assert total == total_original
            if last_iter == DEFAULT_ITERS:
                fp.write('%d & %d & %d & %s & %.2f & %.2f & %s \\\\' %
                         (last_iter, summary[last_iter]['same'], summary[last_iter]['different'],
                          'n/a', summary[last_iter]['same'] / total * 100.0,
                          summary[last_iter]['different'] / total * 100.0, 'n/a'))
            else:
                pc_delta = (summary[last_iter + ITER_STEP]['same'] / total * 100.0) - \
                             (summary[last_iter]['same'] / total * 100.0)
                fp.write('%d & %d & %d & %d & %.2f & %.2f & %.2f\\\\' %
                         (last_iter, summary[last_iter]['same'], summary[last_iter]['different'],
                          summary[last_iter + ITER_STEP]['same'] - summary[last_iter]['same'],
                          summary[last_iter]['same'] / total * 100.0,
                          summary[last_iter]['different'] / total * 100.0, pc_delta))
        fp.write(end_table())
        if with_preamble:
            fp.write(end_document())
    print('Saved: %s' % outfile)


def draw_plot(summary, outfile):
    """Plot 'same' data and write to PDF file."""

    pdf = PdfPages(outfile)
    fig, axis = pyplot.subplots()
    # Prepare data.
    total = float(summary[DEFAULT_ITERS]['same'] + summary[DEFAULT_ITERS]['different'])
    same_data = [summary[last_iter]['same'] / total * 100.0 for last_iter in sorted(summary.keys())]
    min_x, max_x = 0, int(max(summary.keys()))
    min_y, max_y = 0., max(same_data)
    # Plot data.
    axis.plot(sorted(summary.keys()), same_data, marker='.', markersize=2, linestyle='-', color=LINE_COLOUR)
    # Re-style the chart.
    xlim = (min_x - (min_x % 100), max_x)
    major_xticks = range(xlim[0], xlim[1] + ITER_STEP * 20, ITER_STEP * 10)
    major_yticks = compute_grid_offsets(min_y - (min_y % 10), max_y, GRID_MAJOR_Y_DIVS)
    style_axis(axis, major_xticks, [], major_yticks, [], TICK_FONTSIZE)
    axis.set_xticklabels([str(label) for label in major_xticks], rotation=270)
    axis.set_xlabel('#in-process iterations', fontsize=AXIS_FONTSIZE)
    axis.set_ylabel('% of process executions with the same classification as n=2000',
                    fontsize=AXIS_FONTSIZE)
    axis.set_xlim(xlim)
    add_margin_to_axes(axis, x=0.02, y=0.02)
    # Save figure.
    pdf.savefig(fig, dpi=fig.dpi, orientation='portrait', bbox_inches='tight')
    pdf.close()
    print('Saved: %s' % outfile)


def create_cli_parser():
    """Create a parser to deal with command line switches."""

    script = os.path.basename(__file__)
    description = (('Summarise information generated by generate_truncated_json script.\n' +
                    '\n\nExample usage:\n\n' +
                    '\t$ python %s -o summary.tex results.json.bz2') % script)
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('directory', action='store', default='.', type=str,
                        help='Directory containing truncated results files.')
    parser.add_argument('--texfile', '-t', action='store', dest='latex_file',
                        type=str, help='Name of the LaTeX file to write table to.',
                        required=True)
    parser.add_argument('--pdffile', '-p', action='store', dest='plot_file',
                        type=str, help='Name of the PDF file to write plot to.',
                        required=True)
    parser.add_argument('--with-preamble', action='store_true',
                        dest='with_preamble', default=False,
                        help='Write out a whole LaTeX article (not just the table).')
    return parser


if __name__ == '__main__':
    parser = create_cli_parser()
    options = parser.parse_args()
    if options.with_preamble:
        print 'Writing out full document, with preamble.'
    summary = summarise_truncated(options.directory)
    write_table(summary, options.latex_file, options.with_preamble)
    draw_plot(summary, options.plot_file)
